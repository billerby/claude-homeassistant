
# Loads default set of integrations. Do not remove.
default_config:

# Enables Python Scripts
python_script:


# Text to speech
tts:
  - platform: google_translate

automation: !include automations.yaml
script: !include scripts.yaml
scene: !include scenes.yaml


lovelace:
  resources:
    - url: /config/www/community/lovelace-xiaomi-vacuum-card/xiaomi-vacuum-card.js
      type: module
    - url: /root/config/www/community/lovelace-multiple-entity-row/multiple-entity-row.js
    - url: /hacsfiles/battery-state-card/battery-state-card.js
      type: module
    
 
template:
  - sensor:
    - name: "input_power_with_efficiency_loss"
      unique_id: "input_power_with_efficiency_loss"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      state: >-
        {% set inverter_rating = 10000 %} {# adjust this value to the rated power of your inverter #}
        {% set inpower = states('sensor.inverter_input_power')|float(0) %}
        {% if inpower < (inverter_rating*0.1) %}
          {{ inpower * 0.90 }}
        {% elif inpower < (inverter_rating*0.2) %}  
          {{ inpower * 0.95 }}
        {% else %}
          {{ inpower * 0.98 }}
        {% endif %}
    
   # - name: "solar_forecast_hourly_production"
#      friendly_name: "Solar Forecast Hourly Production"
 #     value_template: "{{ state_attr('sensor.solar_forecast_hourly_data', 'result') | tojson }}"
 #     icon: mdi:solar-power
        
    # Stores the water meter reading at midnight
    - name: "water_meter_start_of_day"
      unique_id: "water_meter_start_of_day"
      unit_of_measurement: "m³"
      state_class: total
      state: "{{ states('input_number.water_meter_midnight_value') }}"

    # Calculates today's water usage
    - name: "water_usage_today"
      unique_id: "water_usage_today"
      unit_of_measurement: "m³"
      device_class: water
      state_class: total_increasing
      icon: mdi:water
      state: >
        {% set current = states('sensor.water_meter_total_m3')|float(0) %}
        {% set start = states('input_number.water_meter_midnight_value')|float(0) %}
        {{ (current - start)|round(3) }}
        
    # Creates a human-readable version in liters
    - name: "water_usage_today_liters"
      unique_id: "water_usage_today_liters"
      unit_of_measurement: "L"
      device_class: water
      state_class: total_increasing
      icon: mdi:water
      state: >
        {% set usage = states('sensor.water_usage_today')|float(0) %}
        {{ (usage * 1000)|round(1) }}

    # EV CHARGING: Parse battery schedule to check if battery is charging now
    - name: "Battery Charging Current Hour"
      unique_id: battery_charging_current_hour
      state: >
        {% set ns = namespace(charging=false) %}
        {% for i in range(1, 10) %}
          {% set period_name = 'Period ' ~ i %}
          {% set period = state_attr('sensor.batteries_tou_charging_and_discharging_periods', period_name) %}
          {% if period and '+' in period %}
            {% set parts = period.split('/') %}
            {% if parts|length == 3 %}
              {% set times = parts[0].split('-') %}
              {% if times|length == 2 %}
                {% set start_time = times[0] %}
                {% set end_time = times[1] %}
                {% set day = parts[1]|int(0) %}
                {% set current_day = now().isoweekday() %}
                {% set current_time = now().strftime('%H:%M') %}
                {# Match if same day and within time range #}
                {% if day == current_day and current_time >= start_time and current_time <= end_time %}
                  {% set ns.charging = true %}
                {% endif %}
              {% endif %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ ns.charging }}

    # EV CHARGING: Static power limit based on battery schedule
    - name: "EV Max Power Static"
      unique_id: ev_max_power_static
      unit_of_measurement: "kW"
      device_class: power
      state: >
        {% if is_state('sensor.battery_charging_current_hour', 'True') %}
          6
        {% else %}
          11
        {% endif %}

    # EV CHARGING: Real-time dynamic power available (accounts for grid usage)
    - name: "EV Max Power Available"
      unique_id: ev_max_power_available
      unit_of_measurement: "kW"
      device_class: power
      state: >
        {% set grid_power_w = states('sensor.power_meter_active_power')|float(0) %}
        {% set grid_power_kw = grid_power_w / 1000 %}
        {% set safety_limit = 14.5 %}
        {% set static_max = states('sensor.ev_max_power_static')|float(11) %}
        {% set dynamic_available = safety_limit - grid_power_kw %}
        {% set final_limit = [dynamic_available, static_max]|min %}
        {% if final_limit < 1 %}
          0
        {% else %}
          {{ final_limit|round(1) }}
        {% endif %}

    # EV CHARGING: Cheapest hours - calculated by Node-RED and sent via MQTT
    # See Node-RED flow for calculation logic

  - binary_sensor:
    - name: "High Water Usage"
      state: "{{ (states('sensor.hourly_water_usage')|float(default=0) + states('input_number.last_water_usage')|float(default=0)) > 0.5 }}"

    - name: "Coffee Machine Steam Mode"
      state: "{{ states('input_boolean.coffee_steam_mode_active') == 'on' }}"

    # More reliable steam mode detection using average power over 2 minutes
    - name: "Coffee Machine Steam Mode Detected"
      unique_id: "coffee_machine_steam_mode_detected"
      device_class: heat
      state: >
        {% set current_power = states('sensor.shellyplugg_till_lampan_power')|float(0) %}
        {% set avg_power = states('sensor.coffee_machine_power_2min_avg')|float(0) %}
        {% set machine_on_time = now() - states.automation.satt_pa_kaffemaskin.attributes.last_triggered if states.automation.satt_pa_kaffemaskin.attributes.last_triggered else timedelta(hours=24) %}
        {# Machine must be on for at least 5 minutes to avoid startup detection #}
        {% set startup_period_passed = machine_on_time > timedelta(minutes=5) %}
        {# Steam mode: average power over 1000W for 2 minutes OR current power sustained over 1100W #}
        {{ startup_period_passed and (avg_power > 1000 or current_power > 1100) }}

    # EV CHARGING: Check if we're in off-tariff period
    - name: "Off Tariff Period Active"
      unique_id: off_tariff_period_active
      state: >
        {% set now_hour = now().hour %}
        {% set now_month = now().month %}
        {% set now_weekday = now().isoweekday() %}
        {% set is_winter = now_month >= 11 or now_month <= 3 %}
        {% set is_weekday = now_weekday <= 5 %}
        {% set is_weekend = now_weekday >= 6 %}
        {% set is_off_peak_hours = now_hour >= 20 or now_hour < 7 %}

        {# Off-tariff if: #}
        {# 1. Nov-March weekday nights (20:00-07:00) #}
        {# 2. Nov-March weekends (all day) #}
        {# 3. Apr-Oct (all times) #}
        {% if not is_winter %}
          true
        {% elif is_weekend %}
          true
        {% elif is_weekday and is_off_peak_hours %}
          true
        {% else %}
          false
        {% endif %}

    # EV CHARGING: Should we charge the EV right now?
    - name: "EV Should Charge Now"
      unique_id: ev_should_charge_now
      state: >
        {% set current_hour = now().hour %}
        {% set cheapest_hours = state_attr('sensor.ev_charging_hours_tonight', 'cheapest_hours') %}
        {% set in_cheap_window = current_hour in cheapest_hours if cheapest_hours else false %}
        {% set off_tariff_active = is_state('binary_sensor.off_tariff_period_active', 'on') %}
        {% set cable_locked = is_state('binary_sensor.easee_home_91929_cable_locked', 'on') %}
        {% set smart_enabled = is_state('input_boolean.ev_smart_charging_enabled', 'on') %}
        {% set available_power = states('sensor.ev_max_power_available')|float(0) %}
        {% set current_soc = states('sensor.otto_von_bismarck_battery')|float(0) %}
        {% set target_soc = states('number.otto_von_bismarck_charge_limit')|float(100) %}
        {% set needs_charging = current_soc < target_soc %}
        {{ smart_enabled and off_tariff_active and in_cheap_window and cable_locked and available_power > 1 and needs_charging }}

input_boolean:
  coffee_steam_mode_active:
    name: Coffee Machine Steam Mode Active
    initial: false

  ev_smart_charging_enabled:
    name: EV Smart Charging Enabled
    icon: mdi:ev-station
    initial: false

input_number:
  last_water_usage:
    name: Last Water Usage
    min: 0
    max: 9999999
    step: 0.001
    mode: box

  water_meter_midnight_value:
    name: Water Meter Midnight Value
    min: 0
    max: 999999
    step: 0.001
    mode: box

  ev_charging_power_limit:
    name: EV Charging Power Limit
    min: 1
    max: 11
    step: 0.5
    unit_of_measurement: "kW"
    icon: mdi:speedometer
    mode: box

  ev_charging_current_limit:
    name: EV Charging Current Limit
    min: 6
    max: 16
    step: 1
    unit_of_measurement: "A"
    icon: mdi:current-ac
    mode: box
    
mqtt:
  sensor:
    - name: "water_meter_total_m3"
      json_attributes_topic: "wmbusmeters/MainWater"
      state_topic: "wmbusmeters/MainWater"
      unit_of_measurement: m³
      value_template: "{{ value_json.total_m3 }}"
      state_class: total_increasing
      device_class: water
      icon: "mdi:gauge"

    # EV CHARGING: Cheapest hours from Node-RED (via Tibber prices)
    - name: "EV Charging Hours Tonight"
      unique_id: ev_charging_hours_tonight_mqtt
      state_topic: "homeassistant/sensor/ev_charging_hours/state"
      value_template: "{{ value_json | length }}"
      json_attributes_topic: "homeassistant/sensor/ev_charging_hours/state"
      json_attributes_template: "{{ {'cheapest_hours': value_json} | tojson }}"

sensor:
  # Statistics sensor for coffee machine power averaging
  - platform: statistics
    name: "Coffee Machine Power 2min Avg"
    unique_id: "coffee_machine_power_2min_avg"
    entity_id: sensor.shellyplugg_till_lampan_power
    state_characteristic: mean
    max_age:
      minutes: 2
    sampling_size: 400

  - platform: command_line
    name: pytibber_version
    command: "python3 -c 'import tibber; print(tibber.__version__)' 2>/dev/null || echo 'unknown'"
    scan_interval: 86400  
    
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/badtemperatur-application/devices/eui-a840411f8182f655/packages/storage/uplink_message?limit=1&order=-received_at
    name: Badtemperatur
    value_template: "{{ value_json.result.uplink_message.decoded_payload.TempC1 }}"
    unit_of_measurement: "°C"
    headers:
      Authorization: !secret badtemperatur_token
      Accept: text/event-stream
      
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/badtemperatur-application/devices/eui-a840411f8182f655/packages/storage/uplink_message?limit=1&order=-received_at
    name: Badtemperatur_voltage
    value_template: "{{ value_json.result.uplink_message.decoded_payload.BatV }}"
    unit_of_measurement: "v"
    headers:
      Authorization: !secret badtemperatur_token
      Accept: text/event-stream      
      
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/septitankar/devices/eui-244e7b0000003fe8/packages/storage/uplink_message?limit=1&order=-received_at
    name: Stortank
    value_template: "{{ value_json.result.uplink_message.decoded_payload.ullage_cm }}"
    unit_of_measurement: "cm"
    headers:
      Authorization: !secret septitankar_token2
      Accept: text/event-stream
      
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/septitankar/devices/eui-244e7b0000003fe8/packages/storage/uplink_message?limit=1&order=-received_at
    name: Stortank-battery
    value_template: >-
      {% if value_json.result.uplink_message.decoded_payload.bat_pct is defined %}
        {{ value_json.result.uplink_message.decoded_payload.bat_pct }}
      {% else %}
        {{ states('sensor.stortank_battery') }}
      {% endif %}
    unit_of_measurement: "%"
    headers:
      Authorization: !secret septitankar_token2
      Accept: text/event-stream

      
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/septitankar/devices/eui-244e7b0000003fe8/packages/storage/uplink_message?limit=1&order=-received_at
    name: Stortank-temperatur
    value_template: "{{ value_json.result.uplink_message.decoded_payload.temp_C }}"
    unit_of_measurement: "cm"
    headers:
      Authorization: !secret septitankar_token2
      Accept: text/event-stream      
      
  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/septitankar/devices/eui-24e124713e115756/packages/storage/uplink_message?limit=1&order=-received_at
    name: Lilltank
    value_template: "{{ value_json.result.uplink_message.decoded_payload.distance }}"
    unit_of_measurement: "mm"
    headers:
      Authorization: !secret septitankar_token2
      Accept: text/event-stream

  - platform: rest
    resource: https://eu1.cloud.thethings.network/api/v3/as/applications/septitankar/devices/eui-24e124713e115756/packages/storage/uplink_message?limit=1&order=-received_at
    name: Lilltank-battery
    value_template: "{{ value_json.result.uplink_message.decoded_payload.battery }}"
    unit_of_measurement: "%"
    headers:
      Authorization: !secret septitankar_token2
      Accept: text/event-stream
      
  - platform: rest
    resource: https://api.forecast.solar/estimate/watthours/period/57.71356/12.04249/5/18/11.7
    name: solar_forecast_watts_per_hour
    scan_interval: 86400  # 24 hours 
    json_attributes:
      - result
      - message
    value_template: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"      
      
  - platform: integration
    source: sensor.input_power_with_efficiency_loss
    name: solar_energy_riemann
    round: 3
    
  - platform: template
    sensors:
      large_septitank_level:
        friendly_name: "Large septitank level"
        unit_of_measurement: '%'
        value_template: >
          {% set x = states('sensor.stortank') | float %}
          {% if x is none or x == 'unknown' %}
            unknown
          {% else %}
            {% set min_dist = 2 %}
            {% set max_dist = 80 %}
            {% set normalized = ((x - min_dist) / (max_dist - min_dist)) %}
            {% set inverted = (1 - normalized) * 100 %}
            {{ inverted | round(0) }}
          {% endif %}

  - platform: template
    sensors:
      small_septitank_level:
        friendly_name: "Small septitank level"
        unit_of_measurement: '%'
        value_template: >
          {% set x = states('sensor.lilltank') %}
          {% if x is none or x == 'unknown' %}
            unknown
          {% else %}
            {% set x = x | float %}
            {% set min_dist = 170 %}
            {% set max_dist = 800 %}
            {% set normalized = ((x - min_dist) / (max_dist - min_dist)) %}
            {% set inverted = (1 - normalized) * 100 %}
            {{ inverted | round(0) }}
          {% endif %}

influxdb:
  api_version: 1
  host: 8f49de54-victoria-metrics 
  port: 8428
  max_retries: 3
  measurement_attr: entity_id
  tags_attributes:
    - friendly_name
    - unit_of_measurement
  ignore_attributes:
    - icon
    - source
    - options
    - editable
    - min
    - max
    - step
    - mode
    - marker_type
    - preset_modes
    - supported_features
    - supported_color_modes
    - effect_list
    - attribution
    - assumed_state
    - state_open
    - state_closed
    - writable
    - stateExtra
    - event
    - friendly_name
    - device_class
    - state_class
    - ip_address
    - device_file
    - unit_of_measurement
    - unitOfMeasure
  include:
    domains:
      - sensor
      - binary_sensor
      - light
      - switch
      - cover
      - climate
      - input_boolean
      - input_select
      - number
      - lock
      - weather
  exclude:
    entity_globs:
      - sensor.clock*
      - sensor.date*
      - sensor.glances*
      - sensor.time*
      - sensor.uptime*
      - sensor.dwd_weather_warnings_*
      - weather.weatherstation
      - binary_sensor.*_smartphone_*
      - sensor.*_smartphone_*
      - sensor.adguard_home_*
      - binary_sensor.*_internet_access
      
logger:
  default: warn
  logs:
    pymodbus: error # only include this if you're having connectivity issues
    huawei_solar: info
    homeassistant.components.huawei_solar: info
    homeassistant.components.http: info
    homeassistant.components.rest: info
    custom_components.tibber: info
    homeassistant.components.tibber: info
    tibber: info
    
shell_command:
  # Backup logs with timestamp when HA shuts down
  backup_logs: cp /config/home-assistant.log /config/old-logs/log-backup-`date +"%Y%m%d_%H%M"`.log
  
  # Optional: Clean up old backups (keep only last 7 days)
  cleanup_old_logs: find /config/old-logs -name "log-backup-*" -mtime +7 -delete
    